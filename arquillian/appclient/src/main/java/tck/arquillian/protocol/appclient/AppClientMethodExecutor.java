/*
 * Copyright 2024,2025 Red Hat, Inc., and individual contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 */
package tck.arquillian.protocol.appclient;

import com.sun.ts.tests.common.vehicle.VehicleType;
import org.jboss.arquillian.container.spi.client.deployment.Deployment;
import org.jboss.arquillian.container.spi.context.annotation.DeploymentScoped;
import org.jboss.arquillian.container.test.spi.ContainerMethodExecutor;
import org.jboss.arquillian.core.api.Instance;
import org.jboss.arquillian.core.api.InstanceProducer;
import org.jboss.arquillian.core.api.annotation.ApplicationScoped;
import org.jboss.arquillian.core.api.annotation.Inject;
import org.jboss.arquillian.test.api.ArquillianResource;
import org.jboss.arquillian.test.spi.TestMethodExecutor;
import org.jboss.arquillian.test.spi.TestResult;
import tck.arquillian.protocol.common.TargetVehicle;
import tck.arquillian.protocol.common.TsTestPropsBuilder;

import java.io.File;
import java.io.FileNotFoundException;
import java.nio.file.Path;
import java.util.logging.Logger;

/**
 * AppClientMethodExecutor is responsible for executing the test methods in the context of an application client.
 * It handles the invocation of the app client and processes the results. It has values from the test deployment
 * that are generated by the AppClientDeploymentPackager since the executor does not have access to the test
 * deployment.
 */
public class AppClientMethodExecutor implements ContainerMethodExecutor {
    static Logger log = Logger.getLogger(AppClientMethodExecutor.class.getName());
    private AppClientCmd appClient;
    // This is obtained from the AppClientDeploymentPackager via the packagerConfigInstance
    private AppClientProtocolConfiguration config;
    @Inject
    @DeploymentScoped
    Instance<Deployment> deploymentInstance;
    @Inject
    @DeploymentScoped
    Instance<DeploymentMonitor> deploymentMonitorInstance;

    static enum MainStatus {
        PASSED,
        FAILED,
        ERROR,
        NOT_RUN;

        static MainStatus parseStatus(String reason) {
            MainStatus status = null;
            if (reason.contains("Passed.")) {
                status = PASSED;
            } else if (reason.contains("Failed.")) {
                status = FAILED;
            } else if (reason.contains("Error.")) {
                status = ERROR;
            } else if (reason.contains("Not run.")) {
                status = NOT_RUN;
            }
            return status;
        }
    }

    public AppClientMethodExecutor(AppClientCmd appClient, AppClientProtocolConfiguration config) {
        this.appClient = appClient;
        this.config = config;
    }

    @Override
    public TestResult invoke(TestMethodExecutor testMethodExecutor) {
        TestResult result = TestResult.passed();
        TargetVehicle testVehicle = testMethodExecutor.getMethod().getAnnotation(TargetVehicle.class);

        if(config == null) {
            result = TestResult.failed(new IllegalStateException("AppClientMethodExecutor: no config obtained from packagerConfigInstance"));
            return result;
        }
        AppClientArchiveName appClientArchiveName = config.getAppClientArchiveName();

        // Run the appclient for the test if required
        String testMethod = testMethodExecutor.getMethodName();
        if (config.isRunClient()) {
            DeploymentMonitor deploymentMonitor = deploymentMonitorInstance.get();
            log.info("Running appClient for: %s, monitor: %s".formatted(testMethod, deploymentMonitor));
            try {
                Deployment deployment = deploymentInstance.get();
                String appArchiveName = appClientArchiveName.name();
                String vehicleArchiveName = determineVehicleArchiveName(testVehicle);
                String deploymentName = config.getDeploymentName();

                String appArchiveStubJarName = null;
                if(config.needsStubs() && deploymentMonitor.needsStubs()) {
                    log.info("Getting deployment stubs for: "+appArchiveName);
                    appArchiveStubJarName = getDeploymentStubs();
                } else {
                    log.info("No stubs needed");
                }

                String[] additionalAgrs = TsTestPropsBuilder.runArgs(config, deployment, testMethodExecutor);
                AppClientCmd.AppClientInfo appClientInfo = new AppClientCmd.AppClientInfo(deploymentName, vehicleArchiveName, appArchiveName, appArchiveStubJarName);
                appClient.run(appClientInfo, additionalAgrs);
            } catch (Exception ex) {
                result = TestResult.failed(ex);
                return result;
            }
        } else {
            log.info("Not running appClient for: " + testMethod);
        }

        String[] lines = appClient.readAll(config.getClientTimeout());
        log.info(String.format("AppClient(%s) readAll returned %d lines\n", testMethod, lines.length));

        boolean sawStatus = false;
        boolean expectReason = false;
        MainStatus status = MainStatus.NOT_RUN;
        String reason = "None";
        String description = "None";

        for (String line : lines) {
            System.out.println(line);

            if (expectReason) {
                status = MainStatus.parseStatus(line);
                // If not a valid status line, then keep looking
                if (status != null) {
                    reason = line;
                    description = "STATUS: " + reason;
                    expectReason = false;
                    continue;
                }
            }

            int statusIndex = line.indexOf("STATUS:");

            if (statusIndex >= 0) {
                sawStatus = true;
                // Grab rest of line to check for emptiness
                String remnant = line.substring(statusIndex + "STATUS:".length()).trim();

                if (!remnant.isEmpty()) {
                    description = line;
                    status = MainStatus.parseStatus(line);
                    if (status == null) {
                        status = MainStatus.FAILED;
                    }
                    // Format of line is STATUS:StatusText.Reason
                    // see com.sun.javatest.Status#exit()
                    int reasonStart = line.indexOf('.');
                    if (reasonStart > 0 && reasonStart < line.length() - 1) {
                        reason = line.substring(reasonStart + 1);
                    }
                } else {
                    // Get reason from next line(s)
                    expectReason = true;
                }
            }
        }

        if (!sawStatus) {
            Throwable ex = new IllegalStateException("No STATUS: output seen from client");
            result = TestResult.failed(ex);
        } else {
            switch (status) {
                case PASSED:
                    result = TestResult.passed(reason);
                    break;
                case ERROR:
                case FAILED:
                    result = TestResult.failed(new Exception(reason));
                    break;
                case NOT_RUN:
                    result = TestResult.skipped(reason);
                    break;
            }
            result.addDescription(description);
        }

        return result;
    }

    private String getDeploymentStubs() throws Exception {
        String deploymentName = config.getDeploymentName();
        log.info("Getting deployment stubs, deployment: " + deploymentName);
        String[] cmdLine = config.clientStubsCmdLineAsArray();
        String[] clientEnvp = {};
        for (int n = 0; n < cmdLine.length; n ++) {
            String arg = cmdLine[n];
            if (arg.contains("${deploymentName}")) {
                arg = arg.replaceAll("\\$\\{deploymentName}", deploymentName);
                cmdLine[n] = arg;
            }
        }
        log.info("Running: " + String.join(" ", cmdLine));
        Process stubsProcess = Runtime.getRuntime().exec(cmdLine, clientEnvp, null);
        int exit = stubsProcess.waitFor();
        log.info("Stubs process exited with: " + exit);
        if (exit != 0) {
            throw new RuntimeException("Stubs process failed with exit code: " + exit);
        }

        // The stubs jar is expected to be in target/${deploymentName}${clientStubsJarSuffix}.jar
        String stubsJarName = "%s%s.jar".formatted(deploymentName, config.getClientStubsJarSuffix());
        Path stubsJarPath = Path.of("target", stubsJarName);
        File stubsJarFile = stubsJarPath.toFile();
        if(!stubsJarFile.exists()) {
            String msg = "Expected stubs target/${deploymentName=%s}${clientStubsJarSuffix=%s}.jar not found: %s"
                    .formatted(deploymentName, config.getClientStubsJarSuffix(), stubsJarFile.getAbsolutePath());
            throw new FileNotFoundException(msg);
        }

        return stubsJarFile.getAbsolutePath();
    }

    private String determineVehicleArchiveName(TargetVehicle targetVehicle) {
        String vehicleArchiveName = config.getVehicleArchiveName();
        if((vehicleArchiveName.isEmpty() || vehicleArchiveName.equals("none")) && targetVehicle != null) {
            String vehicle = targetVehicle.value();
            VehicleType vehicleType = VehicleType.valueOf(vehicle);
            switch (vehicleType) {
                case appmanaged, appmanagedNoTx, stateful3, stateless3 ->
                        vehicleArchiveName = vehicleType.name() + "_vehicle_web";
                default ->
                        vehicleArchiveName = vehicleType.name() + "_vehicle";
            }
        }
        return vehicleArchiveName;
    }
}
